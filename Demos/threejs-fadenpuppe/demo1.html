<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Teatro Fadenpuppe – Physics Rig</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f4ead6;  /* Teatro paper */
      touch-action: none;   /* custom drag / pinch */
    }
    canvas { display: block; }
  </style>
</head>
<body>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<!-- Cannon.js (physics) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
  // ===== BASIC THREE SETUP ================================================
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xf4ead6, 1);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  const frustumSize = 40;
  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);

  function updateCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.left   = (frustumSize * aspect) / -2;
    camera.right  = (frustumSize * aspect) /  2;
    camera.top    =  frustumSize / 2;
    camera.bottom = -frustumSize / 2;
    camera.updateProjectionMatrix();
  }
  updateCamera();

  // True isometric base orientation
  const distance = 60;
  let cameraAzimuth = Math.PI / 4;                  // around Y
  const cameraElevation = Math.atan(1 / Math.sqrt(2)); // ~35°

  function updateCameraPosition() {
    camera.position.set(
      distance * Math.cos(cameraAzimuth),
      distance * Math.sin(cameraElevation),
      distance * Math.sin(cameraAzimuth)
    );
    camera.lookAt(0, 5, 0); // look at puppet region
  }
  updateCameraPosition();
  camera.zoom = 1;
  camera.updateProjectionMatrix();

  // Group for visual Teatro room
  const roomGroup = new THREE.Group();
  scene.add(roomGroup);

  const lineMat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 1 });

  function addBoxEdges(width, height, depth, position, parent) {
    const geo = new THREE.BoxGeometry(width, height, depth);
    const edges = new THREE.EdgesGeometry(geo);
    const line  = new THREE.LineSegments(edges, lineMat);
    line.position.copy(position);
    parent.add(line);
    return line;
  }

  // Floor & walls (just outlines)
  addBoxEdges(30, 0.01, 20, new THREE.Vector3(0, 0, 0), roomGroup);
  addBoxEdges(30, 20, 0.01, new THREE.Vector3(0, 10, -10), roomGroup);
  addBoxEdges(0.01, 20, 20, new THREE.Vector3(-15, 10, 0), roomGroup);
  addBoxEdges(0.01, 20, 20, new THREE.Vector3(15, 10, 0), roomGroup);

  // Door on right wall
  (function addDoor() {
    const geo = new THREE.BufferGeometry();
    const pts = [
      new THREE.Vector3(15, 0, -4),
      new THREE.Vector3(15, 8, -4),
      new THREE.Vector3(15, 8, -1),
      new THREE.Vector3(15, 0, -1),
      new THREE.Vector3(15, 0, -4)
    ];
    geo.setFromPoints(pts);
    const door = new THREE.Line(geo, lineMat);
    roomGroup.add(door);
  })();

  // ===== PHYSICS SETUP (CANNON) ==========================================
  const world = new CANNON.World();
  world.broadphase = new CANNON.NaiveBroadphase();
  world.gravity.set(0, -9.82, 0);
  world.solver.iterations = 20;

  // ground plane (for feet collisions)
  const groundBody = new CANNON.Body({
    mass: 0,
    shape: new CANNON.Plane()
  });
  // rotate plane to lie in XZ with Y up
  const q = new CANNON.Quaternion();
  q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
  groundBody.quaternion.copy(q);
  world.addBody(groundBody);

  // ===== UTILS: BUILD RIGID BODY + MESH PAIRS ============================
  const blackMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

  function makeBoxBody(width, height, depth, mass, pos) {
    const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
    const body  = new CANNON.Body({ mass, shape });
    body.position.set(pos.x, pos.y, pos.z);
    world.addBody(body);
    return body;
  }

  function makeBoxMesh(width, height, depth) {
    const geo = new THREE.BoxGeometry(width, height, depth);
    const mesh = new THREE.Mesh(geo, blackMat);
    const edges = new THREE.EdgesGeometry(geo);
    const outline = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ color: 0xf4ead6, linewidth: 2 })
    );
    mesh.add(outline);
    scene.add(mesh);
    return mesh;
  }

  function syncMeshToBody(mesh, body) {
    mesh.position.copy(body.position);
    mesh.quaternion.copy(body.quaternion);
  }

  // ===== PUPPET RIG ======================================================
  const puppet = {};

  // Overhead crossbar (kinematic-ish; mass ~0 but we can move/rotate it)
  puppet.barBody = makeBoxBody(10, 0.2, 0.2, 0.1, new THREE.Vector3(0, 15, 0));
  puppet.barMesh = makeBoxMesh(10, 0.2, 0.2);

  // Torso
  puppet.torsoBody = makeBoxBody(1.6, 3, 0.8, 1.0, new THREE.Vector3(0, 8, 0));
  puppet.torsoMesh = makeBoxMesh(1.6, 3, 0.8);

  // Head
  puppet.headBody  = makeBoxBody(1.1, 1.1, 0.8, 0.5, new THREE.Vector3(0, 10, 0));
  puppet.headMesh  = makeBoxMesh(1.1, 1.1, 0.8);

  // Hands
  puppet.handLBody = makeBoxBody(0.4, 2.0, 0.4, 0.3, new THREE.Vector3(-1.8, 8, 0));
  puppet.handRBody = makeBoxBody(0.4, 2.0, 0.4, 0.3, new THREE.Vector3( 1.8, 8, 0));
  puppet.handLMesh = makeBoxMesh(0.4, 2.0, 0.4);
  puppet.handRMesh = makeBoxMesh(0.4, 2.0, 0.4);

  // Feet
  puppet.footLBody = makeBoxBody(0.5, 2.2, 0.5, 0.4, new THREE.Vector3(-0.6, 5, 0));
  puppet.footRBody = makeBoxBody(0.5, 2.2, 0.5, 0.4, new THREE.Vector3( 0.6, 5, 0));
  puppet.footLMesh = makeBoxMesh(0.5, 2.2, 0.5);
  puppet.footRMesh = makeBoxMesh(0.5, 2.2, 0.5);

  // Joints between bodies (hinge-like / generic constraints)
  // Torso ↔ head
  {
    const pivotTorso = new CANNON.Vec3(0, 1.6, 0);
    const pivotHead  = new CANNON.Vec3(0, -0.5, 0);
    const c = new CANNON.PointToPointConstraint(
      puppet.torsoBody, pivotTorso,
      puppet.headBody,  pivotHead,
      1e4
    );
    world.addConstraint(c);
  }

  // Torso ↔ hand L
  {
    const pivotTorso = new CANNON.Vec3(-0.8, 1.2, 0);
    const pivotHand  = new CANNON.Vec3(0, 1.0, 0);
    const c = new CANNON.PointToPointConstraint(
      puppet.torsoBody, pivotTorso,
      puppet.handLBody, pivotHand,
      1e4
    );
    world.addConstraint(c);
  }

  // Torso ↔ hand R
  {
    const pivotTorso = new CANNON.Vec3(0.8, 1.2, 0);
    const pivotHand  = new CANNON.Vec3(0, 1.0, 0);
    const c = new CANNON.PointToPointConstraint(
      puppet.torsoBody, pivotTorso,
      puppet.handRBody, pivotHand,
      1e4
    );
    world.addConstraint(c);
  }

  // Torso ↔ foot L
  {
    const pivotTorso = new CANNON.Vec3(-0.4, -1.4, 0);
    const pivotFoot  = new CANNON.Vec3(0, 1.0, 0);
    const c = new CANNON.PointToPointConstraint(
      puppet.torsoBody, pivotTorso,
      puppet.footLBody, pivotFoot,
      1e4
    );
    world.addConstraint(c);
  }

  // Torso ↔ foot R
  {
    const pivotTorso = new CANNON.Vec3(0.4, -1.4, 0);
    const pivotFoot  = new CANNON.Vec3(0, 1.0, 0);
    const c = new CANNON.PointToPointConstraint(
      puppet.torsoBody, pivotTorso,
      puppet.footRBody, pivotFoot,
      1e4
    );
    world.addConstraint(c);
  }

  // Strings: bar ↔ head, bar ↔ hand L, bar ↔ hand R
  const stringConstraints = [];

  function addStringConstraint(bodyA, pivotA, bodyB, pivotB) {
    const c = new CANNON.DistanceConstraint(bodyA, bodyB, null, 5e3);
    // Slight hack: we "softly" keep distance via this constraint
    // For visual string, we track bodyA.position + pivotA etc.
    c.pivotA = pivotA.clone();
    c.pivotB = pivotB.clone();
    world.addConstraint(c);
    stringConstraints.push(c);
    return c;
  }

  addStringConstraint(
    puppet.barBody, new CANNON.Vec3(0, 0, 0),
    puppet.headBody, new CANNON.Vec3(0, 0.5, 0)
  );
  addStringConstraint(
    puppet.barBody, new CANNON.Vec3(-2.5, 0, 0),
    puppet.handLBody, new CANNON.Vec3(0, 1.0, 0)
  );
  addStringConstraint(
    puppet.barBody, new CANNON.Vec3( 2.5, 0, 0),
    puppet.handRBody, new CANNON.Vec3(0, 1.0, 0)
  );

  // ===== STRING LINES =====================================================
  function makeStringLine() {
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(6); // 2 points
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 1 });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    return { geo, line };
  }

  const stringLines = stringConstraints.map(() => makeStringLine());

  function updateStrings() {
    for (let i = 0; i < stringConstraints.length; i++) {
      const c = stringConstraints[i];
      const sl = stringLines[i];

      const pa = new CANNON.Vec3();
      const pb = new CANNON.Vec3();
      c.bodyA.position.vadd(c.pivotA, pa);
      c.bodyB.position.vadd(c.pivotB, pb);

      const pos = sl.geo.attributes.position;
      pos.setXYZ(0, pa.x, pa.y, pa.z);
      pos.setXYZ(1, pb.x, pb.y, pb.z);
      pos.needsUpdate = true;
    }
  }

  // ===== CAMERA ORBIT + ZOOM (MOUSE + TOUCH) =============================
  let dragMode = null; // 'orbit'
  let lastX = 0;

  renderer.domElement.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    dragMode = 'orbit';
    lastX = e.clientX;
    renderer.domElement.setPointerCapture(e.pointerId);
  }, { passive: false });

  renderer.domElement.addEventListener('pointermove', (e) => {
    if (dragMode !== 'orbit') return;
    e.preventDefault();
    const dx = e.clientX - lastX;
    lastX = e.clientX;
    cameraAzimuth += dx * 0.003; // sensitivity
    updateCameraPosition();
  }, { passive: false });

  renderer.domElement.addEventListener('pointerup', (e) => {
    dragMode = null;
    renderer.domElement.releasePointerCapture(e.pointerId);
  }, { passive: false });

  // Wheel zoom
  renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    camera.zoom = Math.max(0.5, Math.min(3, camera.zoom * factor));
    camera.updateProjectionMatrix();
  }, { passive: false });

  // Pinch zoom
  let pinchStartDist = 0;
  let pinchStartZoom = 1;

  renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      pinchStartZoom = camera.zoom;
    }
  }, { passive: false });

  renderer.domElement.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2 && pinchStartDist > 0) {
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const ratio = dist / pinchStartDist;
      camera.zoom = Math.max(0.5, Math.min(3, pinchStartZoom * ratio));
      camera.updateProjectionMatrix();
      e.preventDefault();
    }
  }, { passive: false });

  renderer.domElement.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) pinchStartDist = 0;
  }, { passive: false });

  // ===== SIMPLE BAR ANIMATION (TO DRIVE THE PUPPET) ======================
  const barBasePos = puppet.barBody.position.clone();

  function driveBar(time) {
    // Gentle side-to-side motion of the crossbar → puppet swings “physically”
    const sway = Math.sin(time * 0.7) * 2.0;
    const upDown = Math.sin(time * 0.9) * 0.5;
    puppet.barBody.position.x = barBasePos.x + sway;
    puppet.barBody.position.y = barBasePos.y + upDown;
  }

  // ===== RESIZE ==========================================================
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateCamera();
    updateCameraPosition();
  });

  // ===== MAIN LOOP =======================================================
  let lastTime = performance.now() / 1000;

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now() / 1000;
    const dt = Math.min(now - lastTime, 1/30); // clamp step
    lastTime = now;

    // drive bar & step physics
    driveBar(now);
    world.step(1/60, dt, 3);

    // sync meshes
    syncMeshToBody(puppet.barMesh,   puppet.barBody);
    syncMeshToBody(puppet.torsoMesh, puppet.torsoBody);
    syncMeshToBody(puppet.headMesh,  puppet.headBody);
    syncMeshToBody(puppet.handLMesh, puppet.handLBody);
    syncMeshToBody(puppet.handRMesh, puppet.handRBody);
    syncMeshToBody(puppet.footLMesh, puppet.footLBody);
    syncMeshToBody(puppet.footRMesh, puppet.footRBody);

    updateStrings();

    renderer.render(scene, camera);
  }

  animate();
</script>

</body>
</html>